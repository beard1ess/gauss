package operator

import (
	"github.com/beard1ess/gauss/parsing"
	"reflect"
	"strconv"
	"fmt"
)

func recursion(
	original parsing.Keyvalue,
	modified parsing.Keyvalue,
	path []string,
	objectDiff parsing.ConsumableDifference,
) parsing.ConsumableDifference {

<<<<<<< HEAD
	kListModified := parsing.ListStripper(modified)
	kListOriginal := parsing.ListStripper(original)
	if len(kListModified) > 1 || len(kListOriginal) > 1 {
		proc := true

		// If a key which exists in original doesn't exist in modified, add it
		// to the list of removed keys.
		for k, v := range original {
			if parsing.IndexOf(kListModified, k) == -1 {
				removed := parsing.RemovedDifference{Path: parsing.PathFormatter(path), Key: k, Value: v}
				objectDiff.Removed = append(objectDiff.Removed, removed)
				proc = false
			}
		}

		// If a key which exists in modified doesn't exist in original, add it
		// to the list of added keys.
		for k, v := range modified {
			if parsing.IndexOf(kListOriginal, k) == -1 {
				added := parsing.AddedDifference{Path: parsing.PathFormatter(path), Key: k, Value: v}
				objectDiff.Added = append(objectDiff.Added, added)
				proc = false
			}
		}

		if proc {
			for k := range original {
				recursion(parsing.Keyvalue{k: original[k]}, parsing.Keyvalue{k: modified[k]}, path, objectDiff)
			}
		}
		return objectDiff
	}

	// for each key in original
=======
func keys(original parsing.Keyvalue, modified parsing.Keyvalue, path []string) {

	for k, v := range modified {
		if parsing.IndexOf(parsing.ListStripper(original), k) == -1 {
			added := parsing.AddedDifference{Path: parsing.PathFormatter(path), Key: k, Value: v}
			ObjectDiff.Added = append(ObjectDiff.Added, added)
			delete(modified, k)
			fmt.Println("DELETED:  ",k)
		}
	}
	for k, v := range original {
		if parsing.IndexOf(parsing.ListStripper(modified), k) == -1 {
			removed := parsing.RemovedDifference{Path: parsing.PathFormatter(path), Key: k, Value: v}
			ObjectDiff.Removed = append(ObjectDiff.Removed, removed)
			delete(original, k)
			fmt.Println("DELETED:  ",k)
		}
	}

	recursion(original, modified, path)
}

func recursion(original parsing.Keyvalue, modified parsing.Keyvalue, input_path []string) {

	path := make([]string, len(input_path))
	copy(path, input_path)
	if reflect.DeepEqual(original, modified) {
		return
	}

	if !(parsing.UnorderedKeyMatch(original, modified)) {

		keys(original, modified, path)
		return

	}
>>>>>>> master
	for k := range original {
			var valOrig, valMod interface{}
			if reflect.TypeOf(original).Kind() == reflect.String {
				valOrig = original
			} else {
				valOrig = original[k]
			}
			if reflect.TypeOf(modified).Kind() == reflect.String {
				valMod = modified
			} else {
				valMod = modified[k]
			}

<<<<<<< HEAD
		if !(reflect.DeepEqual(valMod, valOrig)) {
			if reflect.TypeOf(valOrig).Kind() == reflect.Map {
				npath = append(path, k)
				recursion(parsing.Remarshal(valOrig), parsing.Remarshal(valMod), npath, objectDiff)
				return objectDiff
			} else if reflect.TypeOf(valOrig).Kind() == reflect.Slice {
				valOrig, _ := valOrig.([]interface{})
				valMod, _ := valMod.([]interface{})
				if len(valOrig) != len(valMod) {
					// TODO array length differences, how to interpret?
					fmt.Println("Cannot handle array length differences yet, sorry not sorry; kind of sorry.")
					os.Exit(1)
				} else {
					for i := range valOrig {
						if !(reflect.DeepEqual(valOrig[i], valMod[i])) {
							iter := len(path) - 1
							path[iter] = path[iter] + "[" + strconv.Itoa(i) + "]"
							recursion(parsing.Remarshal(valOrig[i]), parsing.Remarshal(valMod[i]), path, objectDiff)
							return objectDiff
						}
					}
				}
			} else {
				changed := parsing.ChangedDifference{Path: parsing.PathFormatter(path), Key: k,
					OldValue: valOrig, NewValue: valMod}
				objectDiff.Changed = append(objectDiff.Changed, changed)
				return objectDiff
=======
			if !(reflect.DeepEqual(valMod, valOrig)) {
				if reflect.TypeOf(valOrig).Kind() == reflect.Map {
					path = append(path, k)
					recursion(parsing.Remarshal(valOrig), parsing.Remarshal(valMod), path)
					return
				} else if reflect.TypeOf(valOrig).Kind() == reflect.Slice {
					var match bool
					valOrig, _ := valOrig.([]interface{})
					valMod, _ := valMod.([]interface{})
					path = append(path, k)
					npath := make([]string, len(path))
					if len(valOrig) != len(valMod) {
						if len(valOrig) > len(valMod) {
							for i := range valOrig {
								for ii := range valMod {
									if reflect.DeepEqual(valOrig[i], valMod[ii]) {
										match = true
									} else if i == ii {
										iter := len(path) - 1
										path[iter] = path[iter] + "[" + strconv.Itoa(i) + "]"
										recursion(parsing.Remarshal(valOrig[i]), parsing.Remarshal(valMod[i]), path)
									}
								}
								if !(match) {
									removed := parsing.RemovedDifference{Path: parsing.PathFormatter(path),
										Key:                                   k, Value: valOrig}
									ObjectDiff.Removed = append(ObjectDiff.Removed, removed)
								} else {
									match = false
								}
							}

						} else {
							for i := range valMod {
								for ii := range valOrig {
									if reflect.DeepEqual(valOrig[ii], valMod[i]) {
										match = true
									} else if i == ii {
										iter := len(path) - 1
										path[iter] = path[iter] + "[" + strconv.Itoa(i) + "]"
										recursion(parsing.Remarshal(valOrig[i]), parsing.Remarshal(valMod[i]), path)
									}
								}
								if !(match) {
									added := parsing.AddedDifference{Path: parsing.PathFormatter(path),
										Key:                               k, Value: valMod}
									ObjectDiff.Added = append(ObjectDiff.Added, added)
								} else {
									match = false
								}
							}
						}
					} else {
						for i := range valOrig {
							copy(npath, path)
							if !(reflect.DeepEqual(valOrig[i], valMod[i])) {
								iter := len(npath) - 1
								npath[iter] = npath[iter] + "[" + strconv.Itoa(i) + "]"
								recursion(parsing.Remarshal(valOrig[i]), parsing.Remarshal(valMod[i]), npath)
							}
						}
						return
					}
				} else {
					changed := parsing.ChangedDifference{Path: parsing.PathFormatter(path), Key: k,
						OldValue:                              valOrig, NewValue: valMod}
					ObjectDiff.Changed = append(ObjectDiff.Changed, changed)
					return
				}
>>>>>>> master
			}
		}
		return objectDiff
	}
<<<<<<< HEAD
	return objectDiff
}
=======

>>>>>>> master

func Recursion(original parsing.Keyvalue, modified parsing.Keyvalue, path []string) parsing.ConsumableDifference {

	objectDiff := parsing.ConsumableDifference{}

	return recursion(original, modified, path, objectDiff)
}
